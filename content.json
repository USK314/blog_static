{"pages":[],"posts":[{"title":"北大集中講義のハッカソンに参加しました","text":"先月、北海道大学の集中講義としてハッカソンに参加してきました。技術面での成長はもちろんのこと、これからのプロダクト開発の方針についてもよく考えさせられ、またも大変貴重な経験を積むことができました。 参加の経緯北大は年2回、夏季と冬季にIT系の集中講義を開いているらしいです。ハッカソンをして技術力向上しつつも単位がもらえるというお得イベントです。もちろん出るしかありません。 参加条件の中に「基礎的なプログラミング能力を有していることが望ましい」とありますが、基本的には情報学でPythonをやっている人なら何とかなると思います。 今回は計5チームがありましたが、話を聞く限りどこのチームにも、ある程度の経験者と全くの開発未経験が良い感じに分散していました。「プログラミングなんて何にも分からないから不安…」という人でも興味とやる気さえあれば大丈夫です（多分）。 プロダクト ハッカソン発表資料 今回のハッカソンのテーマは「北海道Socity5.0」でした。そのテーマの中で私たちは観光振興という課題に目を付けて「NAND」というWebアプリを作成しました（プロダクト名の由来についてはスライドページ５のイメージです）。 簡単に説明すると、道内の「まだ魅力が発見されていないスポット」をリコメンドするようなアプリです。世の中には「道内旅行おススメ10選！」とか「ここに行かなきゃもったいない！」という名所の情報はとうに溢れかえっています。しかし北海道にはまだまだ発見されていない、魅力を備えたスポットがたくさんあるはずです。私たちはもっと多くの人にそれに気が付いてほしいと考えました。 ただし、私たちの主観で勝手に「ここは名所じゃないです」と言われるのは誰も良い気持ちがしないでしょう。そこで私たちはNAVITIMEに助けを求めました。カーナビで有名なあのNAVITIMEです。あちらの会社は目的地検索数のデータを所有しているため、検索数が多い方から切っていけば人気か否かの客観的な根拠を取得できると判断しました。 使用技術 今回私はフロントエンドをメインで担当しました。フロントのメンバーはもう2人いたのですが、ともに開発は未経験であったためReactなどのフレームワークは用いずにおとなしく生JSで挑戦しました。バックエンドは別の2人に担当してもらっていましたが、そちらも開発は未経験だったので現在のレベルで私が教えることのできるスタックをそのまま使いました。 というわけで、なんと自分以外は全員開発未経験というチームでした（競プロerなどはいましたが）。しかも全員B1でした。今までのハッカソンは分からないことがあっても先輩に聞けば何でも解決してくれましたが、今回はそうもいきません。いつかは自分も人に教えられるようにならないとな、とか呑気に考えていたら想像以上に早く来てしまいました… それでもtakapiroさんにアドバイスをもらいながらなんとかやり遂げました。最初の方はしっかりと計画立てて進めることができていましたが、アクシデントなどで進捗がでないことが重なって、最終日にはちゃんと徹夜しました。自分が経験したことのある実装は何となく段取りも分かっていましたが、初めてのものについては簡単に思えても当てがはずれることが多かったですね。今までのハッカソンの中では最もアウトプットの多い回だったので、とても学びがありました。 UX について思うところさて、今回のハッカソンでは技術力以外にもよく注意したものがありました。それはずばりUXです。UXというとデザインの面から言われることが多い(？)気がしますが、もっと広い意味でのユーザーエクスペリメントを意識しました。 それにはこんな経緯がありました。 私は昨年の秋 JPHacks2021 に参加し（参加記はこちら）、北海道・東北ブロックでは見事優勝できたものの、全国大会では一つも賞をもらえないという結果に終わってしまいました。率直にとても残念でした。一体何が原因だったのか不思議に思い、JPHacksを主催した株式会社ギブリーのまっくすさんにコンタクトを取りました。そして今回のハッカソンの期間中にお話を聞いてきました。 敗因について端的に言えば、 デモをライブでできなかったこと ターゲットを絞り切れていなかったこと の2点が挙げられました。特に2つ目については非常に熱く語っていただき、大変身になるお話でした。そこから私なりに解釈した学びを語っていきたいと思います。 中途半端すぎたら結局誰も喜ばないまっくすさんとお話しする前、私は「より多くの人が喜ぶプロダクトを目指せばそれでいい」と思ってました。確かにその考え方は誤りではないと思います。しかし大勢の人が喜ぶようなものを制作できることはプロでも非常に難しく、いわば理想論に近いものだと思います。 実際、日本の自動車業界最大手であるトヨタ自動車でもマーケットシェア率は47.7%.です（出典：業界動向サーチ）。これは決してトヨタが低いわけではありません。コトラーは競争地位の類型化を図りましたが、業界シェア率が30～40％.さえあれば、それはリーダーと呼ばれるらしいです（by 経営学）。それでは一体何を目指せばいいのでしょうか。まっくすさんと対談から、私は以下のように考えました。 「100人全員を満足させられなくてもいいから、ただ１人を心から満足させたい」 なんだか若干ポエムっぽくなってしまったのは心外ですが、要するにこういうことなんじゃないかと思います。1人すら喜ばせられずに大勢の人を喜ばせることはできません。そのためにはターゲットとなる人の状況や困っていること、その根底には何をしてほしいという欲求があるのかを丁寧に見極める必要があります。しっかりとユーザーの顔を想像して、これからもプロダクト制作に励んでいきたいと思いました。 このハッカソンを通して得られたこと話を本筋に戻します。先ほどもお話ししましたが、今回のハッカソンでは特にアウトプット量が多かったため、非常に多くのことを学べました。 1人1人の進捗を見てタスクを割り振りつつ、自分も進捗を生まなければならないことの難しさ今回は初めてハッカソンでリーダーを務めたわけですが、自分にまだそこまでの技術力がありはしないため、他の人にアドバイスをしつつ自分も学んでコーディングするという同時作業になかなか苦労しました。そのためには適宜PDCAを回していくことが重要だなと思いました。 技術的なところ JS、axios/fetch、firebase hosting、herokuのデプロイ方法、環境変数、**.gitignore、XMLHttpRequest、BootStrap**など、新しく知ったことや、それまでは知っていただけで今回ようやくその役割を理解したものがとても多くありました。アウトプットするためにはある程度体系的に理解しておくことも大切だと思うので、またどんどんインプットもしていきたいですね。 主観的に捉えられがちなデータを客観的にみなすこれは私たちのプロダクトが講評者の方々に最も評価されたポイントでした。今回私たちはたまたま「人気スポットか否かをデータに基づいて判別すればいい」と気づくことができたわけですが、これからもそういった考え方を持てるようにするためにも意識的にそれができるようになることが大事だと思います。 イメージに縛られない他のチームでは「高齢者の方にも見やすいように字を大きくして～」という話がありました。私はそれを聞いて「確かにな～」と考えていましたが、講評者の中のお1人が「それは高齢者に対するありがちなイメージですよね」とコメントしました。おそらく私も高齢者をターゲットにするのであれば「フォントサイズやカラーに気を遣えばいいだろう」と考えていたと思います。でも果たしてそれでいいのでしょうか。実はこの問題については自分の中でも答えは見つかっていません。 今月はまた別のハッカソンに出場してみる予定です。今回学んだことを活かし、より良いプロダクトを制作できるように頑張ります！ 終わり","link":"/blog_static/2022/03/05/HU-intensive-lecture/"},{"title":"getとstreamって何が違う？","text":"この記事は、HUIT アドベントカレンダー 2021 の10日目の記事です。 今回は初めての技術系記事です。色々と足りないところはあるかもしれませんが、どうか温かい目で見てください。改善点など大歓迎です！ この記事はFirebaseからPythonでデータを取得する際に用いるget()とstream()の違いについて考察したものです。 そもそもDBとはみなさんは普段どんなDBを使っているのでしょうか。MySQL、PostgreSQL、MongoDBなど様々な種類がありますが、私はまだFirestore DBしか用いたことがありません。DBの操作とかも興味があったりするのでこれから色々扱ってみたいですね。 念のためデータベースというものがよく分からないという方に説明すると、 データベースは、アプリケーションのデータを保存・蓄積するためのひとつの手段です。大量のデータを蓄積しておいて、そこから必要な情報を抜き出したり、更新したりということが柔軟に行えるため、多くのデータを扱うアプリケーションでは欠かすことができません。（出典：キタミ式イラストIT塾 基本情報技術者 令和03年） とのことです。確かに過去2回のハッカソンにおいてもデータベースがあると無いとでは出来ることが全然違うなーと思ってました。 事の経緯前回の記事でも紹介しましたがつい先日JPHacksに参加し、私はバックエンドを担当していました。 その際もFirestore DBを利用したのですが、DBからデータを持ってこようとしっかり公式ドキュメントを参照し、言うとおりにコードを書いていたところ、事件が起きました。stream型では上手く行っていたはずのコードがget型では実行されなかったのです。以下、どのように実行しなかったのかを再現したコードを載せます。 ・・・・・・・・・・・ get型でも出来てしまいました…… 「違う、君じゃない」 開発時はあれほど希望を与えてくれた200番台が、今では失望に変わってしまいました。「アドカレ当日になってまさかの没記事か……？」と背筋が凍りかけましたが、気にせずこのまま突っ走ろうと思います。 結局get()とstream()のどっちを使えばいいのか？無事(?)get型でも実装はできましたが、やはりその過程には違いがあるはずだと踏んで果敢に攻め入ります。 公式ドキュメントに気になる点がありました。 Note: Use of CollectionRef stream() is prefered to get()とありますが、これは他の言語には無い記述です。また、「複数」ではなく「単一」のドキュメントを取得する方法を示す箇所にはこのような記述はありませんでした。 というわけで、「POSTメソッドで登録したmemberの情報を全て取得する」というコードをget型とstream型の2パターンで記述したものがこちらです。 違いはdb.collection(&quot;members&quot;)につけたメソッドのみです。ともにコード内でdocsを出力するようにしています。 以下、上のコードによって出力されたものです。 123456789101112131415161718192021222324252627282930＊get型＊docs : [&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BE50&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BE20&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277E9EF5130&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BC40&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045550&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA0456A0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045610&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045040&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA0457C0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045B20&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045AC0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045FA0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045A90&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045940&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1644C0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1640D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1645B0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1645E0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1643D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164670&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164700&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164790&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164820&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1648B0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164940&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1649D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164A60&gt;] 1234＊stream型＊docs : &lt;generator object Query.stream at 0x00000277E9FEFC10&gt; せいぜい少しだけ内部の操作が異なるのかなあとか思ってましたがまさかここまで視覚に訴えかけてくるものだとは…… それでは早速私の稚拙な知識で分析を試みていきます。 分析フェーズ get型 特徴的なのはやはり27行にわたる出力結果ですが、この27という数字はFirestore上のドキュメント（レコードと同じ）の数です。データを取得するためにあらかじめ投稿しておきました。get型はそのそれぞれについてDocumentSnapshotを作成し、配列型としてdocsに入れてくれているんですね。 さて、DocumentSnapshotとは何なのでしょうか。 大変分かりやすいサイトがありましたので紹介します。 →FirestoreのReferenceとSnapshotの大まかな理解（Tips） こちらをちゃんと読んでもらえればきっと大まかに分かるんだと思います（私も今はさらっと読みましたが後ほどしっかりと読みます。新情報が入荷次第ここに更新していきたいですね） 以下、大変ざっくりまとめた図です。 12345678910Firebaseのオブジェクト群- Reference オブジェクトが存在する＊場所＊ - DocumentReference - CollectionReference- Snapshot オブジェクトの＊データ＊ - DocumentSnapshot - QuerySnapshot - QueryDocumentSnapshot なんとなく分かったのでOKです。 stream型 こちらはget型とは打って変わってシンプルに一行！ まずgeneratorとは何か。generatorと大体セットで出てくるものにiteratorがある、ということくらいなら私でもなんとなく分かっています。開発中何度も見なかったふりをしました iteratorは繰り返し？generatorはiteratorを作成する関数？ 色々書いてありましたがサッと見ただけじゃよくわからなかったし、もう少しちゃんと調べてみたい気もしたので後日別記事として出すかもしれません。とりあえず今回は保留ということで:man-bowing: 次にQuery.streamについて。これについてはあまりいい情報を得られませんでした。streamは「データの流れ」を意味するみたいなので何となく言ってることは分かるような気がしますが…… ただ、ネットの散歩中にこんなことが書かれた記事を見つけました。 node.jsのStreamを使えばメモリを節約することができます。出典：node-mysqlとStreamで大量のデータを効率的に処理 あくまでnode.jsについて言及したものであること、そしてメモリの節約については特に説明がなされていなかった気がするので確証の無い情報ではありますが、もし仮にこれが正しく、かつPythonでも成り立つのであれば公式ドキュメントが「getよりもstreamの方がいいよ！」と言っていたことの裏付けになるかもしれません。 たしかにget型はドキュメントのそれぞれについてDocumentSnapshotを作成する仕様だったのでドキュメント数が増えれば増えるほど大変そうだなあとは思いました。 他に気になったこと先ほど2パターンの記述方法でコードを記載しましたが、どちらもdocsという変数を設定した後にfor文で回してdocを取ってきています。実はこちらもそれぞれget型とstream型の2パターンについてprint(doc)したのですが、これが面白いことにほぼ一致したんですね。 123＊get型＊&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x0000019B9F641C10&gt; 123＊stream型＊&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x0000019B9F50F520&gt; 異なったのは末尾から6桁の文字列のみで、それ以外は同じ形式でした。docsの形はあれだけ違うのにfor文で回した途端ほとんど同じものが出力されるってどういうことなんでしょうか。こちらについてはこの記事では検証せず、将来的な展望としておきます。 まとめ結論：おそらくいちいちドキュメントをSnapshotにするget型はメモリを浪費することになるため、stream型にした方が良いだろう ということになりました。未検証な部分もいくつかありましたが、それについては追々調べていこうと思います。 技術系記事と打って出た割には雑なものに仕上がった気がしますが大目に見ていただければ幸いです。 明日のアドカレ記事はまたも未定です（3回目）誰か書いてください！ 終わり","link":"/blog_static/2021/12/11/get%E3%81%A8stream%E3%81%A3%E3%81%A6%E4%BD%95%E3%81%8C%E9%81%95%E3%81%86%EF%BC%9F/"},{"title":"HUITに入ってみたお話","text":"この記事は、HUIT アドベントカレンダー 2021 の４日目の記事です。 昨日はtakapiroさんの冬割クーポンの自動通知のお話でした。先日のJPHacks（後ほどこれについても記事書きます）ではtakapiroさんにもクーポンにも大変お世話になりましたね。 さて、この記事はHUITに入部してから現在に至るまでのドキュメンタリーを書き綴ったものです HUIT に入部するまで（高校時代～大学入学）高校時代、プログラミングに手を出している友人がいたことで当時からプログラミングに興味はありましたが、どうしたらいいか分からず特に何もしませんでした。 大学入学後、サークルを探しているとHUITという何やら面白そうなサークルが……ここを見つけてからというもの、まずは下調べをと思いホームページを見たり過去のブログを見たりしました。その過程で、昨年行われていたHUITのアドカレ2020も実は見てました。 技術系の記事は当時の自分にはサッパリ分かりませんでしたが、自身が面白いと思うことに手を出しまくっている人たちの話を読んでいると、そんな人たちが集まったHUITがすごく魅力的なサークルに思えました。もちろん新歓行って即入部:tada: 入部後のはなし（大学入学後～8月）かくしてこのサークルに入ったわけですが、当時の私のIT常識度と言えば「CPU？HTML？名前すら知りません！」というレベルでした。プログラミング面白そうと思ったものの、当然具体的に何ができるのか知るはずもありません。 とりあえず適当に初心者に分かりやすくて人気があると評判のPythonを相棒に選んで、とりあえずネット記事を全部コピペして参考にbotや簡単なゲーム(マインスイーパーとか)を作ってみましたが、どうしても、なんか違うな感が拭えませんでした。 また、IT系の知識が皆無に等しかったため、どうにかして体系的な知識を得ようとしていました。当初していたのは、とにかくサークル内で話題に上がった言葉をメモして意味調べです。←でもその説明文も意味わからん ←結果 ”知ってる” ワードは増えても ”分かってる” ワードは微増 そこで夏休みを機に基本情報技術者試験の参考書(キタミ式)を読みました。さすが資格試験の参考書とあって体系的にまとめられていたため、サークル内でよく聞く言葉がどんどん脳内地図に形成されて行ってすごく面白かったですね。その時説明で何言ってるか分からなかったとしても、とりあえず適当にメモしたり調べてみたりしたのは無駄ではなかったと思います。※ちなみに上の本を読み終わったころには試験まで時間が無く、基本情報は見送って来年応用情報を受けようと思ってます。 ハッカソン（9月～）そして9月からはハッカソンに参加するようになりました。一応分からない方のために、ハッカソンとは 与えられたテーマに即したプロダクトをある期間中に考案から開発、プレゼンまでを行うことです。 こう聞くと敷居が高いように思われるかもしれませんが、やってみると意外となんとかなります。（実際自分も技術力に不安を持ちながらも、先輩方に「気楽にやっていいよ」と後押ししてもらって参加を決意しました） 賛否あるかもしれませんが（無いかもしれませんが）、私はプログラミングを始めて数か月が経った方にぜひハッカソンをお勧めしたいです。理由は2つほどあります。 モチベ維持 先輩方も言っていたように、やはりプログラミングというのは明確な目的（ハッカソンに出たい！競プロのレートを上げたい！Webやゲームを作ってみたい！ etc…）を自分の中で持っていないとモチベが下がりやすいです。実際私も意気揚々と入部したものの、6,7月あたりはモチベが下降気味でした。 圧倒的アウトプット モチベが少し下がりつつもなんとなく知識は取り入れるようにしていましたが、なかなか自分一人だと（それこそ明確な作りたいものが無い人にとっては）どうしてもインプットに偏りがちです。ハッカソンの制作期間は普通短めなので、とにかくひたすらアウトプットしないとゴールに間に合いません。嫌でも大量にアウトプットさせるというのが特に初学者にとっては魅力的に思います。（とは書いたものの、実際は優しい先輩方が教えてくださったため全然怖いコンテストではないのでご安心を） 以上の点から、ハッカソンはすごくおススメですね！ただし、起きている間のリソースの大部分を割くことになるので課題諸々とのバランスは注意が必要です。 記事冒頭でも書きましたが、ハッカソンについてのより詳しい話は後ほど執筆予定なのでぜひそちらも見てくれると嬉しいです！ 申し遅れましたが私は北大B1の文系です。HUIT（@huitgroup）は大学・学年・学部の垣根が全く無いサークルなのでぜひぜひ気軽に覗いてみてください。 明日の記事はくーじろーさんが書いてくれるみたいですお楽しみに！ 終わり","link":"/blog_static/2021/12/04/HUIT%E3%81%AB%E5%85%A5%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%8A%E8%A9%B1/"},{"title":"JPHacks2021に参加しました！","text":"この記事は、HUIT アドベントカレンダー 2021 の７日目の記事です。 昨日はくーじろーさんのawaitの裏側のお話でした。今回私がJPHacksでプロダクトを制作した際にも非同期処理を扱いましたが、相変わらず何言ってるのか分からない記事でした笑（難しくて） さて、今回は私が今年参加したハッカソンの体験を書き綴っていきます。 参加の経緯HUITでハッカソンの募集が投げられていたことで興味を持ち、JPHacksに先輩方とチームを組んで出場しました。 実はJPHacksに参加する前にテクのこというSCSK主催のハッカソンにもHUITチームとして参加しており、その際はtakapiroさんに教えてもらいながらPythonのfastapiというフレームワークを用いてバックエンドを担当しました。 そこでも非常にいい経験をさせていただいたのですが、「もっと開発したい！」という思いから、テクのこメンバー ＋ kokiさんという強力助っ人と共にJPHacksにも参戦することになりました。 プロダクト私たちのチームはCOCONOMASKというプロダクトを作りました。ざっくり言えばCOCOAのbluetooth信号を拾うことで、近くに人がいるかどうかを判断して自動開閉するマスクです。以下のものは発表用スライドです。 githubレポジトリはこちら 結果としては賞をいただくことは叶いませんでしたが、非常に楽しく、学びのあるハッカソンでした！！ 担当機能私はPythonのfastapiというフレームワークを用いてバックエンドを担当しました。 テクのこの際にも同様の技術を扱っていたのですが、正直私はtakapiroさんの説明を聞くのが精一杯で実質的には今回が初のコーディングです。メンバー登録、ログイン機能、家族機能(JPHacks後半戦で消滅したのでスライドにはありません)を実装しました。 firestore上のデータを扱うのに非常に試行錯誤しましたが、無事JSON受け渡し係としての役目は果たせたと思います。 感想 普通こんないい経験させてもらえるのか 大学入学したのを機にプログラミング始めてから半年くらいしか経っていないのにJPHacks本戦を経験させてもらえるなんて驚きですね。本当に先輩方様様です。ありがとうございました！ githubの扱い分かってきた 反省会の時にtakapiroさんが言っていたことですが、個人で開発するよりもハッカソンのようにチームで開発したほうがgithubの有用性がよく分かるというのは確かにそうだなと思いました。これからも積極的に使っていきたいです。 とにかく調べまくって実験しまくることが大事 どうやって機能を実装してみればいいのか分からないとき、どうやってエラーを解決したらいいのか分からないとき、公式ドキュメントや同様の質問が投げられているサイトをとにかく読み漁ってみれば案外何とかなるなと思いました。人に聞く前にまず自分で調べるのは基本（自戒） コードリーディングの重要性に気が付く これまでは人が書いたコードをしっかりと読み込んだことがありませんでしたが、１行１行丁寧にさらっていくことで、それが何をしようとしたコードなのかを理解でき、さらにその技術を自分に取り込むことができるのだなと実感しました。 そもそもの技術力をしっかりと持っておきたい テクのこもJPHacksもそうですが、オンライン開催だからなのか共に2週間以上の制作期間が設けられていました。そのおかげもあってじっくりと学びながら実装していくことができましたが、本来ハッカソンはもっと期間が短いらしい（？）ので事前にある程度の技術力を備えておかなければならないなと思いました。 今後やっていきたい技術このハッカソンを機に、今後やりたいことがたくさんできました ネイティブアプリ（Dart） React・Node.js 機械学習 ハード SQL etc… （「これ全部できます」ってサラッと言えたら強すぎる）視野を広く持ちつつも、地に足つけてこれからも頑張って勉強します！ 最後に、共にJPHacksで戦ったメンバーのみなさんのブログも貼っておきます takapiroさん 前編 takapiroさん 後編 kokiさん 前編 kokiさん 後編 usatyoさん 明日のアドカレはkokiさんの:HuggingFace:の記事です！お楽しみに！ 終わり","link":"/blog_static/2021/12/07/JPHacks2021%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F%EF%BC%81/"}],"tags":[{"name":"huit","slug":"huit","link":"/blog_static/tags/huit/"},{"name":"poem","slug":"poem","link":"/blog_static/tags/poem/"},{"name":"beginner","slug":"beginner","link":"/blog_static/tags/beginner/"},{"name":"hackathon","slug":"hackathon","link":"/blog_static/tags/hackathon/"},{"name":"JPHacks","slug":"JPHacks","link":"/blog_static/tags/JPHacks/"},{"name":"python","slug":"python","link":"/blog_static/tags/python/"},{"name":"firebase","slug":"firebase","link":"/blog_static/tags/firebase/"},{"name":"db","slug":"db","link":"/blog_static/tags/db/"},{"name":"event","slug":"event","link":"/blog_static/tags/event/"},{"name":"HU","slug":"HU","link":"/blog_static/tags/HU/"}],"categories":[]}