{"pages":[],"posts":[{"title":"HUITに入ってみたお話","text":"この記事は、HUIT アドベントカレンダー 2021 の４日目の記事です。 昨日はtakapiroさんの冬割クーポンの自動通知のお話でした。先日のJPHacks（後ほどこれについても記事書きます）ではtakapiroさんにもクーポンにも大変お世話になりましたね。 さて、この記事はHUITに入部してから現在に至るまでのドキュメンタリーを書き綴ったものです HUIT に入部するまで（高校時代～大学入学）高校時代、プログラミングに手を出している友人がいたことで当時からプログラミングに興味はありましたが、どうしたらいいか分からず特に何もしませんでした。 大学入学後、サークルを探しているとHUITという何やら面白そうなサークルが……ここを見つけてからというもの、まずは下調べをと思いホームページを見たり過去のブログを見たりしました。その過程で、昨年行われていたHUITのアドカレ2020も実は見てました。 技術系の記事は当時の自分にはサッパリ分かりませんでしたが、自身が面白いと思うことに手を出しまくっている人たちの話を読んでいると、そんな人たちが集まったHUITがすごく魅力的なサークルに思えました。もちろん新歓行って即入部:tada: 入部後のはなし（大学入学後～8月）かくしてこのサークルに入ったわけですが、当時の私のIT常識度と言えば「CPU？HTML？名前すら知りません！」というレベルでした。プログラミング面白そうと思ったものの、当然具体的に何ができるのか知るはずもありません。 とりあえず適当に初心者に分かりやすくて人気があると評判のPythonを相棒に選んで、とりあえずネット記事を全部コピペして参考にbotや簡単なゲーム(マインスイーパーとか)を作ってみましたが、どうしても、なんか違うな感が拭えませんでした。 また、IT系の知識が皆無に等しかったため、どうにかして体系的な知識を得ようとしていました。当初していたのは、とにかくサークル内で話題に上がった言葉をメモして意味調べです。←でもその説明文も意味わからん ←結果 ”知ってる” ワードは増えても ”分かってる” ワードは微増 夏休みを機に基本情報技術者試験の参考書(キタミ式)を読みました。さすが資格試験の参考書とあって体系的にまとめられていたため、サークル内でよく聞く言葉がどんどん脳内地図に形成されて行ってすごく面白かったですね。その時説明で何言ってるか分からなかったとしても、とりあえず適当にメモしたり調べてみたりしたのは無駄ではなかったと思います。※ちなみに上の本を読み終わったころには試験まで時間が無く、基本情報は見送って来年応用情報を受けようと思ってます。 ハッカソン（9月～）そして9月からはハッカソンに参加するようになりました。一応分からない方のために、ハッカソンとは 与えられたテーマに即したプロダクトをある期間中に考案から開発、プレゼンまでを行うことです。 こう聞くと敷居が高いように思われるかもしれませんが、やってみると意外となんとかなります。（実際自分も技術力に不安を持ちながらも、先輩方に「気楽にやっていいよ」と後押ししてもらって参加を決意しました） 賛否あるかもしれませんが（無いかもしれませんが）、私はプログラミングを始めて数か月が経った方にぜひハッカソンをお勧めしたいです。理由は2つほどあります。 モチベ維持 先輩方も言っていたように、やはりプログラミングというのは明確な目的（ハッカソンに出たい！競プロのレートを上げたい！Webやゲームを作ってみたい！ etc...）を自分の中で持っていないとモチベが下がりやすいです。実際私も意気揚々と入部したものの、6,7月あたりはモチベが下降気味でした。 圧倒的アウトプット モチベが少し下がりつつもなんとなく知識は取り入れるようにしていましたが、なかなか自分一人だと（それこそ明確な作りたいものが無い人にとっては）どうしても**インプット**に偏りがちです。ハッカソンの制作期間は普通短めなので、とにかくひたすら**アウトプット**しないとゴールに間に合いません。嫌でも大量にアウトプットさせるというのが特に初学者にとっては魅力的に思います。（とは書いたものの、実際は優しい先輩方が教えてくださったため全然怖いコンテストではないのでご安心を） 以上の点から、ハッカソンはすごくおススメですね！ただし、起きている間のリソースの大部分を割くことになるので課題諸々とのバランスは注意が必要です。 記事冒頭でも書きましたが、ハッカソンについてのより詳しい話は後ほど執筆予定なのでぜひそちらも見てくれると嬉しいです！ 申し遅れましたが私は北大B1の文系です。HUIT（@huitgroup）は大学・学年・学部の垣根が全く無いサークルなのでぜひぜひ気軽に覗いてみてください。 明日の記事はくーじろーさんが書いてくれるみたいですお楽しみに！ 終わり","link":"/blog_static/2021/12/04/HUIT%E3%81%AB%E5%85%A5%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%8A%E8%A9%B1/"},{"title":"JPHacks2021に参加しました！","text":"この記事は、HUIT アドベントカレンダー 2021 の７日目の記事です。 昨日はくーじろーさんのawaitの裏側のお話でした。今回私がJPHacksでプロダクトを制作した際にも非同期処理を扱いましたが、相変わらず何言ってるのか分からない記事でした笑（難しくて） さて、この記事は私が今年参加したハッカソンの体験を書き綴ったものです。 参加の経緯HUITでハッカソンの募集が投げられていたことで興味を持ち、JPHacksに先輩方とチームを組んで出場しました。 実はJPHacksに参加する前にテクのこというSCSK主催のハッカソンにもHUITチームとして参加していました。そこではtakapiroさんに教えてもらいながらPythonのfastapiというフレームワークを用いてバックエンドを担当しました。 そこでも非常にいい経験をさせていただいたのですが、「もっと開発したい！」という思いから、テクのこメンバー ＋ kokiさんという強力助っ人と共にJPHacksにも参戦することになりました。 プロダクト私たちのチームはCOCONOMASKというプロダクトを作りました。ざっくり言えばCOCOAのbluetooth信号を拾うことで、近くに人がいるかどうかを判断して自動開閉するマスクです。以下のものは発表用スライドです。 githubレポジトリはこちら 結果としては賞をいただくことは叶いませんでしたが、非常に楽しく、学びのあるハッカソンでした！！ 担当機能私はPythonのfastapiというフレームワークを用いてバックエンドを担当しました。 テクのこの際にも同様の技術を扱っていたのですが、正直私はtakapiroさんの説明を聞くのが精一杯で実質的には今回が初のコーディングになりました。メンバー登録、家族機能(JPHacks後半戦で消滅したのでスライドにはありません)、ログイン機能を実装しました。 firestore上のデータを扱うのに非常に試行錯誤しましたが、無事JSON受け渡し係としての役目は果たせたと思います。 感想 普通こんないい経験させてもらえるのか 大学入学したのを機にプログラミング始めてから半年くらいしか経っていないのにJPHacks本戦を経験させてもらえるなんて驚きですね。本当に先輩方様様です。ありがとうございました！ githubの扱い分かってきた 反省会の時にtakapiroさんが言っていたことですが、個人で開発するよりもハッカソンのようにチームで開発したほうがgithubの有用性がよく分かるというのは確かにそうだなと思いました。これからも積極的に使っていきたいです。 とにかく調べまくって実験しまくることが大事 どうやって機能を実装してみればいいのか分からないとき、どうやってエラーを解決したらいいのか分からないとき、公式ドキュメントや同様の質問が投げられているサイトを読み漁ってみれば案外何とかなると思いました。人に聞く前にまず自分で調べるのは基本（自戒） コードリーディングの重要性に気が付く これまでは人が書いたコードをしっかりと読み込んだことがありませんでしたが、１行１行丁寧にさらっていくことで何をしようとしたコードなのかを理解することができ、さらにその技術を自分に取り組むことができると思いました。 そもそもの技術力をしっかりと持っておきたい テクのこもJPHacksもそうですが、オンライン開催だからなのか共に2週間以上の制作期間が設けられていました。そのおかげもあってじっくりと学びながら実装していくことができましたが、本来はもっと期間が短いらしい（？）ので事前にある程度の技術力を備えておかなければならないなと思いました。 今後やっていきたい技術このハッカソンを機に、今後やりたいことがたくさんできました ネイティブアプリ（Dart） React・Node.js 機械学習 ハード SQL （「これ全部できます」ってサラッと言えたら強すぎる）視野を広く持ちつつも、地に足つけてこれからも頑張って勉強します 共にJPHacksで戦ったメンバーのみなさんのブログも貼っておきます takapiroさん 前編 takapiroさん 後編 kokiさん 前編 kokiさん 後編 usatyoさん 明日のアドカレ記事はまたも未定です！誰か書いてください！！ 終わり","link":"/blog_static/2021/12/07/JPHacks2021%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F%EF%BC%81/"},{"title":"getとstreamって何が違う？","text":"この記事は、HUIT アドベントカレンダー 2021 の10日目の記事です。 今回は初めての技術系記事です。色々と足りないところはあるかもしれませんが、どうか温かい目で見てください。改善点など大歓迎です！ この記事はFirebaseからPythonでデータを取得する際に用いるget()とstream()の違いについて考察したものです。 そもそもDBとはみなさんは普段どんなDBを使っているのでしょうか。MySQL、PostgreSQL、MongoDBなど様々な種類がありますが、私はまだFirestore DBしか用いたことがありません。DBの操作とかも興味があったりするのでこれから色々扱ってみたいですね。 念のためデータベースというものがよく分からないという方に説明すると、 データベースは、アプリケーションのデータを保存・蓄積するためのひとつの手段です。大量のデータを蓄積しておいて、そこから必要な情報を抜き出したり、更新したりということが柔軟に行えるため、多くのデータを扱うアプリケーションでは欠かすことができません。（出典：キタミ式イラストIT塾 基本情報技術者 令和03年） とのことです。確かに過去2回のハッカソンにおいてもデータベースがあると無いとでは出来ることが全然違うなーと思ってました。 事の経緯前回の記事でも紹介しましたがつい先日JPHacksに参加し、私はバックエンドを担当していました。 その際もFirestore DBを利用したのですが、DBからデータを持ってこようとしっかり公式ドキュメントを参照し、言うとおりにコードを書いていたところ、事件が起きました。stream型では上手く行っていたはずのコードがget型では実行されなかったのです。以下、どのように実行しなかったのかを再現したコードを載せます。 ・・・・・・・・・・・ get型でも出来てしまいました…… 「違う、君じゃない」 開発時はあれほど希望を与えてくれた200番台が、今では失望に変わってしまいました。「アドカレ当日になってまさかの没記事か……？」と背筋が凍りかけましたが、気にせずこのまま突っ走ろうと思います。 結局get()とstream()のどっちを使えばいいのか？無事(?)get型でも実装はできましたが、やはりその過程には違いがあるはずだと踏んで果敢に攻め入ります。 公式ドキュメントに気になる点がありました。 Note: Use of CollectionRef stream() is prefered to get()とありますが、これは他の言語には無い記述です。また、「複数」ではなく「単一」のドキュメントを取得する方法を示す箇所にはこのような記述はありませんでした。 というわけで、「POSTメソッドで登録したmemberの情報を全て取得する」というコードをget型とstream型の2パターンで記述したものがこちらです。 違いはdb.collection(&quot;members&quot;)につけたメソッドのみです。ともにコード内でdocsを出力するようにしています。 以下、上のコードによって出力されたものです。 123456789101112131415161718192021222324252627282930＊get型＊docs : [&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BE50&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BE20&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277E9EF5130&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA03BC40&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045550&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA0456A0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045610&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045040&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA0457C0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045B20&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045AC0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045FA0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045A90&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA045940&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1644C0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1640D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1645B0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1645E0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1643D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164670&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164700&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164790&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164820&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1648B0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164940&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA1649D0&gt;, &lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x00000277EA164A60&gt;] 1234＊stream型＊docs : &lt;generator object Query.stream at 0x00000277E9FEFC10&gt; せいぜい少しだけ内部の操作が異なるのかなあとか思ってましたがまさかここまで視覚に訴えかけてくるものだとは…… それでは早速私の稚拙な知識で分析を試みていきます。 分析フェーズ get型 特徴的なのはやはり27行にわたる出力結果ですが、この27という数字はFirestore上のドキュメント（レコードと同じ）の数です。データを取得するためにあらかじめ投稿しておきました。get型はそのそれぞれについてDocumentSnapshotを作成し、配列型としてdocsに入れてくれているんですね。 さて、DocumentSnapshotとは何なのでしょうか。 大変分かりやすいサイトがありましたので紹介します。 →FirestoreのReferenceとSnapshotの大まかな理解（Tips） こちらをちゃんと読んでもらえればきっと大まかに分かるんだと思います（私も今はさらっと読みましたが後ほどしっかりと読みます。新情報が入荷次第ここに更新していきたいですね） 以下、大変ざっくりまとめた図です。 12345678910Firebaseのオブジェクト群- Reference オブジェクトが存在する＊場所＊ - DocumentReference - CollectionReference- Snapshot オブジェクトの＊データ＊ - DocumentSnapshot - QuerySnapshot - QueryDocumentSnapshot なんとなく分かったのでOKです。 stream型 こちらはget型とは打って変わってシンプルに一行！ まずgeneratorとは何か。generatorと大体セットで出てくるものにiteratorがある、ということくらいなら私でもなんとなく分かっています。開発中何度も見なかったふりをしました iteratorは繰り返し？generatorはiteratorを作成する関数？ 色々書いてありましたがサッと見ただけじゃよくわからなかったし、もう少しちゃんと調べてみたい気もしたので後日別記事として出すかもしれません。とりあえず今回は保留ということで:man-bowing: 次にQuery.streamについて。これについてはあまりいい情報を得られませんでした。streamは「データの流れ」を意味するみたいなので何となく言ってることは分かるような気がしますが…… ただ、ネットの散歩中にこんなことが書かれた記事を見つけました。 node.jsのStreamを使えばメモリを節約することができます。出典：node-mysqlとStreamで大量のデータを効率的に処理 あくまでnode.jsについて言及したものであること、そしてメモリの節約については特に説明がなされていなかった気がするので確証の無い情報ではありますが、もし仮にこれが正しく、かつPythonでも成り立つのであれば公式ドキュメントが「getよりもstreamの方がいいよ！」と言っていたことの裏付けになるかもしれません。 たしかにget型はドキュメントのそれぞれについてDocumentSnapshotを作成する仕様だったのでドキュメント数が増えれば増えるほど大変そうだなあとは思いました。 他に気になったこと先ほど2パターンの記述方法でコードを記載しましたが、どちらもdocsという変数を設定した後にfor文で回してdocを取ってきています。実はこちらもそれぞれget型とstream型の2パターンについてprint(doc)したのですが、これが面白いことにほぼ一致したんですね。 123＊get型＊&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x0000019B9F641C10&gt; 123＊stream型＊&lt;google.cloud.firestore_v1.base_document.DocumentSnapshot object at 0x0000019B9F50F520&gt; 異なったのは末尾から6桁の文字列のみで、それ以外は同じ形式でした。docsの形はあれだけ違うのにfor文で回した途端ほとんど同じものが出力されるってどういうことなんでしょうか。こちらについてはこの記事では検証せず、将来的な展望としておきます。 まとめ結論：おそらくいちいちドキュメントをSnapshotにするget型はメモリを浪費することになるため、stream型にした方が良いだろう ということになりました。未検証な部分もいくつかありましたが、それについては追々調べていこうと思います。 技術系記事と打って出た割には雑なものに仕上がった気がしますが大目に見ていただければ幸いです。 明日のアドカレ記事はまたも未定です（3回目）誰か書いてください！ 終わり","link":"/blog_static/2021/12/11/get%E3%81%A8stream%E3%81%A3%E3%81%A6%E4%BD%95%E3%81%8C%E9%81%95%E3%81%86%EF%BC%9F/"}],"tags":[{"name":"huit","slug":"huit","link":"/blog_static/tags/huit/"},{"name":"poem","slug":"poem","link":"/blog_static/tags/poem/"},{"name":"beginner","slug":"beginner","link":"/blog_static/tags/beginner/"},{"name":"hackathon","slug":"hackathon","link":"/blog_static/tags/hackathon/"},{"name":"JPHacks","slug":"JPHacks","link":"/blog_static/tags/JPHacks/"},{"name":"python","slug":"python","link":"/blog_static/tags/python/"},{"name":"firebase","slug":"firebase","link":"/blog_static/tags/firebase/"},{"name":"db","slug":"db","link":"/blog_static/tags/db/"}],"categories":[]}